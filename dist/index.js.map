{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/adapters/InMemoryStorageAdapter.ts","../src/adapters/PlasmoStorageAdapter.ts","../src/providers/SandshrewRpcProvider.ts","../src/helpers.ts","../src/utils.ts","../src/handlers/TransactionHandler.ts","../src/IntentSynchronizer.ts","../src/IntentManager.ts"],"sourcesContent":["export * from \"./types\";\nexport * from \"./adapters\";\nexport * from \"./providers\";\nexport { IntentSynchronizer } from \"./IntentSynchronizer\";\nexport { IntentManager } from \"./IntentManager\";\n","import { RuneEtchingSpec, RunestoneSpec } from \"@magiceden-oss/runestone-lib\";\n\nexport enum IntentStatus {\n  Pending = \"pending\",\n  Completed = \"completed\",\n  Failed = \"failed\",\n}\n\nexport enum IntentType {\n  Transaction = \"transaction\",\n}\n\nexport interface BaseIntent {\n  id: string;\n  timestamp: number;\n  address: string;\n  status: IntentStatus;\n  reason?: string;\n}\n\nexport enum TransactionType {\n  Send = \"send\",\n  Receive = \"receive\",\n  Trade = \"trade\",\n}\n\nexport enum AssetType {\n  BTC = \"btc\",\n  BRC20 = \"brc-20\",\n  RUNE = \"rune\",\n  COLLECTIBLE = \"collectible\",\n}\n\nexport enum BRC20Operation {\n  Deploy = \"deploy\",\n  Mint = \"mint\",\n  Transfer = \"transfer\",\n}\n\nexport enum RuneOperation {\n  Etching = \"etching\",\n  Mint = \"mint\",\n  Transfer = \"transfer\",\n}\n\nexport interface TransactionIntent extends BaseIntent {\n  type: IntentType.Transaction;\n  transactionType: TransactionType;\n  assetType: AssetType;\n  transactionIds: string[];\n  btcAmount: number;\n}\n\nexport interface BTCTransactionIntent extends TransactionIntent {\n  assetType: AssetType.BTC;\n  amount: number;\n}\n\nexport interface BRC20TransactionIntent extends TransactionIntent {\n  assetType: AssetType.BRC20;\n  ticker: string;\n  tickerAmount?: number;\n  operation: BRC20Operation;\n  max?: number;\n  limit?: number;\n}\n\nexport interface RuneEtchingTransactionIntent extends TransactionIntent {\n  assetType: AssetType.RUNE;\n  operation: RuneOperation.Etching;\n  runeName: string;\n  inscription?: CategorizedInscription;\n}\n\nexport interface RuneMintTransactionIntent extends TransactionIntent {\n  assetType: AssetType.RUNE;\n  operation: RuneOperation.Mint;\n  runeId: string;\n  runeName: string;\n  runeAmount: bigint;\n  runeDivisibility: number;\n}\n\nexport interface RuneTransferTransactionIntent extends TransactionIntent {\n  assetType: AssetType.RUNE;\n  operation: RuneOperation.Transfer;\n  runeId: string;\n  runeName: string;\n  runeAmount: bigint;\n  runeDivisibility: number;\n}\n\nexport type RuneTransactionIntent =\n  | RuneEtchingTransactionIntent\n  | RuneMintTransactionIntent\n  | RuneTransferTransactionIntent;\n\nexport interface CollectibleTransactionIntent extends TransactionIntent {\n  assetType: AssetType.COLLECTIBLE;\n  inscriptionId: string;\n  contentType: string;\n  content: string;\n}\n\nexport interface BRC20TradeTransactionIntent extends TransactionIntent {\n  assetType: AssetType.BRC20;\n  transactionType: TransactionType.Trade;\n  ticker: string;\n  tickerAmount: number;\n  totalPrice: number;\n}\n\nexport type WalletIntent =\n  | BTCTransactionIntent\n  | BRC20TransactionIntent\n  | RuneTransactionIntent\n  | CollectibleTransactionIntent\n  | BRC20TradeTransactionIntent;\n\nexport type CapturableIntent<T extends WalletIntent> = Omit<\n  T,\n  \"id\" | \"timestamp\"\n>;\n\nexport type UpdatableIntent = Partial<\n  Pick<WalletIntent, \"transactionIds\" | \"status\" | \"reason\">\n>;\n\nexport interface CapturedIntent {\n  intent: WalletIntent;\n  update: (intent: UpdatableIntent) => Promise<WalletIntent>;\n}\n\nexport type NewIntent = Omit<WalletIntent, \"id\" | \"timestamp\">;\nexport type PartialExistingIntent = Partial<\n  Omit<WalletIntent, \"id\" | \"timestamp\">\n> & { id: string };\n\nexport interface IntentHandler {\n  captureIntent(\n    intent: CapturableIntent<WalletIntent>\n  ): Promise<CapturedIntent>;\n  retrieveAllIntents(): Promise<WalletIntent[]>;\n  retrievePendingIntentsByAddresses(\n    addresses: string[]\n  ): Promise<WalletIntent[]>;\n  retrieveIntentsByAddresses(addresses: string[]): Promise<WalletIntent[]>;\n  retrieveIntentById(intentId: string): Promise<WalletIntent>;\n  onIntentCaptured(listener: (intent: WalletIntent) => void): void;\n}\n\nexport interface IntentSynchronizer {\n  start(): Promise<void>;\n}\n\nexport interface StorageAdapter {\n  save(intent: NewIntent | PartialExistingIntent): Promise<WalletIntent>;\n  findAll(): Promise<WalletIntent[]>;\n  findByType(type: IntentType): Promise<WalletIntent[]>;\n  findByStatusAndAddresses(\n    status: IntentStatus,\n    addresses: string[]\n  ): Promise<WalletIntent[]>;\n  findByAddresses(addresses: string[]): Promise<WalletIntent[]>;\n  findById(intentId: string): Promise<WalletIntent>;\n  deleteAll(): Promise<void>;\n}\n\nexport interface RpcProvider {\n  baseUrl: string;\n  getTxById(txId: string): Promise<EsploraTransaction>;\n  getAddressTxs(address: string): Promise<EsploraTransaction[]>;\n  getTxOutput(txId: string, index: number): Promise<OrdOutput>;\n  getInscriptionById(inscriptionId: string): Promise<OrdInscription>;\n  getRuneById(runeId: string): Promise<OrdRune>;\n}\n\nexport interface EsploraTransaction {\n  txid: string;\n  version: number;\n  locktime: number;\n  vin: {\n    txid: string;\n    vout: number;\n    prevout: {\n      scriptpubkey: string;\n      scriptpubkey_asm: string;\n      scriptpubkey_type: string;\n      scriptpubkey_address: string;\n      value: number;\n    };\n    scriptsig: string;\n    scriptsig_asm: string;\n    witness: string[];\n    is_coinbase: boolean;\n    sequence: number;\n  }[];\n  vout: {\n    scriptpubkey: string;\n    scriptpubkey_asm: string;\n    scriptpubkey_type: string;\n    scriptpubkey_address?: string;\n    value: number;\n  }[];\n  size: number;\n  weight: number;\n  fee: number;\n  status: {\n    confirmed: boolean;\n    block_height?: number;\n    block_hash?: string;\n    block_time?: number;\n  };\n}\n\nexport interface OrdOutput {\n  address: string;\n  indexed: boolean;\n  inscriptions: string[];\n  runes: any[];\n  sat_ranges: number[][];\n  script_pubkey: string;\n  spent: boolean;\n  transaction: string;\n  value: number;\n}\n\nexport interface OrdRune {\n  entry: {\n    block: number;\n    burned: number;\n    divisibility: number;\n    etching: string;\n    mints: number;\n    number: number;\n    premine: number;\n    spaced_rune: string;\n    symbol: string;\n    terms: {\n      amount: number;\n      cap: number;\n      height: any[];\n      offset: any[];\n    };\n    timestamp: number;\n    turbo: boolean;\n  };\n  id: string;\n  mintable: boolean;\n  parent: string;\n}\n\nexport type OrdInscription = {\n  content_type: string;\n  content: string;\n};\n\nexport type Inscription = {\n  id: string;\n  content_type: string;\n  content: string;\n};\n\nexport type Rune = RunestoneSpec;\n\nexport interface ParsedBRC20 {\n  p: string;\n  op: string;\n  amt: string;\n  tick: string;\n  max?: string;\n  lim?: string;\n}\n\nexport interface CollectibleAsset extends Inscription {\n  assetType: AssetType.COLLECTIBLE;\n}\n\nexport interface Brc20Asset extends ParsedBRC20 {\n  assetType: AssetType.BRC20;\n}\n\nexport interface RuneAsset extends Rune {\n  assetType: AssetType.RUNE;\n  inscription?: Inscription | null;\n}\n\nexport type CategorizedInscription = Brc20Asset | CollectibleAsset;\n","import {\n  IntentStatus,\n  IntentType,\n  NewIntent,\n  PartialExistingIntent,\n  StorageAdapter,\n  WalletIntent,\n} from \"../types\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport class InMemoryStorageAdapter implements StorageAdapter {\n  private intents: WalletIntent[] = [];\n\n  async save(intent: NewIntent | PartialExistingIntent): Promise<WalletIntent> {\n    if (\"id\" in intent) {\n      const index = this.intents.findIndex((i) => i.id === intent.id);\n      if (index === -1) {\n        throw new Error(`Intent with ID ${intent.id} not found`);\n      }\n      const existingIntent = this.intents[index];\n      const updatedIntent = {\n        ...existingIntent,\n        ...intent,\n        timestamp: existingIntent.timestamp,\n      } as WalletIntent;\n      this.intents[index] = updatedIntent;\n      return updatedIntent;\n    } else {\n      const newIntent = {\n        ...intent,\n        id: uuidv4(),\n        timestamp: Date.now(),\n      } as WalletIntent;\n      this.intents.push(newIntent);\n      return newIntent;\n    }\n  }\n\n  async findAll(): Promise<WalletIntent[]> {\n    return this.intents.toSorted((a, b) => b.timestamp - a.timestamp);\n  }\n\n  async findByType(type: IntentType): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.type === type)\n    );\n  }\n\n  async findByStatus(status: IntentStatus): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.status === status)\n    );\n  }\n\n  async findByAddresses(addresses: string[]): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => addresses.includes(intent.address))\n    );\n  }\n\n  async findByStatusAndAddresses(\n    status: IntentStatus,\n    addresses: string[]\n  ): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter(\n        (intent) =>\n          intent.status === status && addresses.includes(intent.address)\n      )\n    );\n  }\n\n  async findById(intentId: string): Promise<WalletIntent> {\n    return this.findAll().then((intents) =>\n      intents.find(({ id }) => id === intentId)\n    );\n  }\n\n  async deleteAll(): Promise<void> {\n    this.intents = [];\n  }\n}\n","import {\n  WalletIntent,\n  IntentStatus,\n  IntentType,\n  StorageAdapter,\n  NewIntent,\n  PartialExistingIntent,\n} from \"../types\";\nimport { Storage } from \"@plasmohq/storage\";\nimport { v4 as uuidv4 } from \"uuid\";\n\ndeclare global {\n  interface BigInt {\n    toJSON(): string;\n  }\n}\n\n// Mokey patch for BigInt serialization in Plasmo Storage\nBigInt.prototype.toJSON = function () {\n  return this.toString();\n};\n\nexport class PlasmoStorageAdapter implements StorageAdapter {\n  private storage: Storage;\n  private key: string;\n\n  constructor(key: string) {\n    this.key = key;\n    this.storage = new Storage({\n      area: \"local\",\n    });\n  }\n\n  async save(intent: NewIntent | PartialExistingIntent): Promise<WalletIntent> {\n    const intents = await this.findAll();\n    let updatedIntent: WalletIntent;\n\n    if (\"id\" in intent) {\n      const newIntents = intents.map((existingIntent) => {\n        if (existingIntent.id === intent.id) {\n          updatedIntent = {\n            ...existingIntent,\n            ...intent,\n            timestamp: existingIntent.timestamp,\n          } as WalletIntent;\n          return updatedIntent;\n        }\n        return existingIntent;\n      });\n\n      await this.storage.set(this.key, newIntents);\n    } else {\n      updatedIntent = {\n        ...intent,\n        id: uuidv4(),\n        timestamp: Date.now(),\n      } as WalletIntent;\n\n      intents.push(updatedIntent);\n      await this.storage.set(this.key, intents);\n    }\n\n    return updatedIntent;\n  }\n\n  async findAll(): Promise<WalletIntent[]> {\n    return this.storage.get<WalletIntent[]>(this.key).then((intents) => {\n      const sortedIntents = (intents || []).sort(\n        (a, b) => b.timestamp - a.timestamp\n      );\n      return sortedIntents;\n    });\n  }\n\n  async findByType(type: IntentType): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.type === type)\n    );\n  }\n\n  async findByStatus(status: IntentStatus): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.status === status)\n    );\n  }\n\n  async findByAddresses(addresses: string[]): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => addresses.includes(intent.address))\n    );\n  }\n\n  async findByStatusAndAddresses(\n    status: IntentStatus,\n    addresses: string[]\n  ): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter(\n        (intent) =>\n          intent.status === status && addresses.includes(intent.address)\n      )\n    );\n  }\n\n  async findById(intentId: string): Promise<WalletIntent> {\n    return this.findAll().then((intents) =>\n      intents.find((intent) => intent.id === intentId)\n    );\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.storage.remove(this.key);\n  }\n}\n","import {\n  RpcProvider,\n  EsploraTransaction,\n  OrdInscription,\n  OrdOutput,\n  OrdRune,\n} from \"../types\";\n\nexport class SandshrewRpcProvider implements RpcProvider {\n  baseUrl: string;\n\n  constructor({ network, projectId }: { network: string; projectId: string }) {\n    if (network === \"regtest\") {\n      this.baseUrl = \"http://localhost:3000/v1/regtest\";\n    } else {\n      this.baseUrl = `https://${network}.sandshrew.io/v1/${projectId}`;\n    }\n  }\n\n  async getAddressTxs(address: string): Promise<EsploraTransaction[]> {\n    try {\n      const response = await fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"esplora_address::txs\",\n          params: [address],\n        }),\n      });\n\n      const data = await response.json();\n      return data.result;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async getTxById(txId: string): Promise<EsploraTransaction> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"esplora_tx\",\n        params: [txId],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n\n  async getTxOutput(txId: string, voutIndex: number): Promise<OrdOutput> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"ord_output\",\n        params: [`${txId}:${voutIndex}`],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n\n  async getInscriptionById(inscriptionId: string): Promise<OrdInscription> {\n    const [inscriptionResponse, contentResponse] = await Promise.all([\n      fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"ord_inscription\",\n          params: [inscriptionId],\n        }),\n      }),\n      fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"ord_content\",\n          params: [inscriptionId],\n        }),\n      }),\n    ]);\n\n    const inscriptionData = await inscriptionResponse.json();\n    const contentData = await contentResponse.json();\n\n    return {\n      ...inscriptionData.result,\n      content: contentData.result,\n    };\n  }\n\n  async getRuneById(runeId: string): Promise<OrdRune> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"ord_rune\",\n        params: [runeId],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n}\n","import { parseWitness } from \"micro-ordinals\";\nimport { tryDecodeRunestone, isRunestone } from \"@magiceden-oss/runestone-lib\";\n\nimport {\n  ParsedBRC20,\n  EsploraTransaction,\n  Inscription,\n  OrdOutput,\n  Rune,\n} from \"./types\";\n\nexport function isReceiveTx(tx: EsploraTransaction, addresses: string[]) {\n  const addressInOutput = tx.vout.find((output) =>\n    addresses.includes(output.scriptpubkey_address)\n  );\n\n  const addressInInput = tx.vin.find((input) =>\n    addresses.includes(input.prevout.scriptpubkey_address)\n  );\n\n  return !!addressInOutput && !addressInInput;\n}\n\nexport function determineReceiverAddress(\n  tx: EsploraTransaction,\n  addresses: string[]\n) {\n  for (const output of tx.vout) {\n    if (addresses.includes(output.scriptpubkey_address)) {\n      return output.scriptpubkey_address;\n    }\n  }\n}\n\nexport function determineReceiverAmount(\n  tx: EsploraTransaction,\n  addresses: string[]\n) {\n  let amount = 0;\n\n  for (const output of tx.vout) {\n    if (addresses.includes(output.scriptpubkey_address)) {\n      amount += output.value;\n    }\n  }\n\n  return amount;\n}\n\nexport function inscriptionIdsFromTxOutputs(txOutputs: OrdOutput[]) {\n  let inscriptionIds: string[] = [];\n  for (let output of txOutputs) {\n    inscriptionIds = inscriptionIds.concat(output.inscriptions);\n  }\n\n  return inscriptionIds;\n}\n\nexport function getInscriptionsFromInput(\n  input: {\n    txid: string;\n    witness: string[];\n  },\n  parentTxId: string\n) {\n  if (input.witness.length < 3) return [];\n\n  const inscriptions: Inscription[] = [];\n\n  try {\n    const parsedInscriptions = parseWitness(\n      input.witness.map((witness) =>\n        Uint8Array.from(Buffer.from(witness, \"hex\"))\n      )\n    );\n\n    if (!parsedInscriptions) {\n      return inscriptions;\n    }\n\n    for (let inscription of parsedInscriptions) {\n      inscriptions.push({\n        id: `${parentTxId}i0`,\n        content_type: inscription.tags.contentType!!,\n        content: uint8ArrayToBase64(inscription.body),\n      });\n    }\n  } catch (error) {\n    console.error(\"Error parsing inscriptions from input\", error);\n  }\n\n  return inscriptions;\n}\n\nexport function getRuneFromOutputs(\n  vout: EsploraTransaction[\"vout\"]\n): Rune | null {\n  const asBtcoinCoreTxVout = vout.map((output) => ({\n    scriptPubKey: {\n      hex: output.scriptpubkey,\n    },\n  }));\n\n  const artifact = tryDecodeRunestone({ vout: asBtcoinCoreTxVout });\n\n  if (artifact && isRunestone(artifact)) {\n    return artifact;\n  }\n  return null;\n}\n\nexport function uint8ArrayToBase64(uint8Array: Uint8Array) {\n  let binaryString = \"\";\n  const len = uint8Array.byteLength;\n  for (let i = 0; i < len; i++) {\n    binaryString += String.fromCharCode(uint8Array[i]);\n  }\n  return btoa(binaryString);\n}\n\nexport function parseBrc20Inscription(\n  inscription: Inscription\n): ParsedBRC20 | void {\n  const contentBuffer = Buffer.from(inscription.content, \"base64\");\n  try {\n    let parsed = JSON.parse(contentBuffer.toString());\n    if (parsed.p === \"brc-20\") {\n      return parsed;\n    }\n  } catch {}\n}\n","export function parseNumber(value?: string): number | null {\n  if (!value) return null;\n  const parsed = parseFloat(value);\n  return isNaN(parsed) ? null : parsed;\n}\n","import { IntentManager } from \"../IntentManager\";\nimport {\n  parseBrc20Inscription,\n  determineReceiverAddress,\n  getInscriptionsFromInput,\n  inscriptionIdsFromTxOutputs,\n  determineReceiverAmount,\n  getRuneFromOutputs,\n} from \"../helpers\";\nimport {\n  IntentStatus,\n  EsploraTransaction,\n  Inscription,\n  RpcProvider,\n  WalletIntent,\n  IntentType,\n  CategorizedInscription,\n  AssetType,\n  TransactionType,\n  BRC20TransactionIntent,\n  CollectibleTransactionIntent,\n  BTCTransactionIntent,\n  RuneOperation,\n  RuneMintTransactionIntent,\n  RuneEtchingTransactionIntent,\n  RuneTransferTransactionIntent,\n} from \"../types\";\nimport { parseNumber } from \"../utils\";\n\nexport class TransactionHandler {\n  private addresses: string[] = [];\n\n  constructor(private manager: IntentManager, private provider: RpcProvider) {}\n\n  private async setAddresses(addresses: string[]) {\n    this.addresses = addresses;\n  }\n\n  async handlePendingTransaction(intent: WalletIntent) {\n    const transactions = await Promise.all(\n      intent.transactionIds.map((txId: string) => this.provider.getTxById(txId))\n    );\n\n    const isConfirmed =\n      transactions.length > 0 &&\n      transactions.every((tx: EsploraTransaction) => tx.status?.confirmed);\n\n    if (isConfirmed) {\n      intent.status = IntentStatus.Completed;\n      await this.manager.captureIntent(intent);\n    }\n  }\n\n  async handleTransactions(addresses: string[], syncFromTimestamp?: number) {\n    this.setAddresses(addresses);\n  \n    const txs = await this.fetchAllTransactions();\n  \n    const filteredTxs = this.filterTransactionsByTimestamp(txs, syncFromTimestamp);\n  \n    await this.processNewTransactions(filteredTxs);\n  }\n  \n  private async fetchAllTransactions() {\n    const txs = await Promise.all(\n      this.addresses.map((addr) => this.provider.getAddressTxs(addr))\n    );\n    return txs.flat();\n  }\n  \n  private filterTransactionsByTimestamp(txs: EsploraTransaction[], syncFromTimestamp?: number) {\n    if (!syncFromTimestamp) return txs;\n  \n    return txs.filter((tx) => tx.status.confirmed \n      ? tx.status.block_time * 1000 >= syncFromTimestamp \n      : true\n    );\n  }\n  \n  private async processNewTransactions(txs: EsploraTransaction[]): Promise<void> {\n    for (const tx of txs) {\n      const txExists = await this.txExists(tx);\n      if (!txExists) {\n        await this.processTransaction(tx);\n      }\n    }\n  }\n\n  private async processTransaction(tx: EsploraTransaction) {\n    const inscriptions = await this.getInscriptions(tx);\n    const [categorized] = this.categorizeInscriptions(inscriptions);\n    const rune = getRuneFromOutputs(tx.vout);\n\n    const address = determineReceiverAddress(tx, this.addresses);\n    const status = tx.status.confirmed\n      ? IntentStatus.Completed\n      : IntentStatus.Pending;\n    const btcAmount = determineReceiverAmount(tx, this.addresses);\n\n    if (this.manager.debug) {\n      console.log(\"Processing transaction\", {\n        address,\n        status,\n        btcAmount,\n        inscriptions,\n        categorized,\n        rune,\n      });\n    }\n\n    if (rune && categorized?.assetType !== AssetType.BRC20) {\n      if (rune.etching) {\n        await this.manager.captureIntent({\n          address,\n          status,\n          btcAmount,\n          type: IntentType.Transaction,\n          assetType: AssetType.RUNE,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          operation: RuneOperation.Etching,\n          runeName: rune.etching.runeName,\n          inscription: categorized || null,\n        } as RuneEtchingTransactionIntent);\n      } else if (rune.mint) {\n        const runeId = `${rune.mint.block}:${rune.mint.tx}`;\n        const runeDetails = await this.provider.getRuneById(runeId);\n\n        await this.manager.captureIntent({\n          address,\n          status,\n          btcAmount,\n          type: IntentType.Transaction,\n          assetType: AssetType.RUNE,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          operation: RuneOperation.Mint,\n          runeId: `${rune.mint.block}:${rune.mint.tx}`,\n          runeName: runeDetails.entry.spaced_rune,\n          runeAmount: rune.edicts[0].amount,\n          runeDivisibility: runeDetails.entry.divisibility,\n        } as RuneMintTransactionIntent);\n      } else {\n        const { amount, id } = rune.edicts[0];\n        const runeId = `${id.block}:${id.tx}`;\n        const runeDetails = await this.provider.getRuneById(runeId);\n\n        await this.manager.captureIntent({\n          address,\n          status,\n          btcAmount,\n          type: IntentType.Transaction,\n          assetType: AssetType.RUNE,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          operation: RuneOperation.Transfer,\n          runeId,\n          runeName: runeDetails.entry.spaced_rune,\n          runeAmount: amount,\n          runeDivisibility: runeDetails.entry.divisibility,\n        } as RuneTransferTransactionIntent);\n      }\n\n      return;\n    }\n\n    switch (categorized?.assetType) {\n      case AssetType.BRC20:\n        await this.manager.captureIntent({\n          address,\n          status,\n          btcAmount,\n          type: IntentType.Transaction,\n          assetType: AssetType.BRC20,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          ticker: categorized.tick,\n          tickerAmount: parseNumber(categorized.amt),\n          operation: categorized.op,\n          max: parseNumber(categorized.max),\n          limit: parseNumber(categorized.lim),\n        } as BRC20TransactionIntent);\n        break;\n\n      case AssetType.COLLECTIBLE:\n        await this.manager.captureIntent({\n          address,\n          status,\n          btcAmount,\n          type: IntentType.Transaction,\n          assetType: AssetType.COLLECTIBLE,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          inscriptionId: categorized.id,\n          contentType: categorized.content_type,\n          content: categorized.content,\n        } as CollectibleTransactionIntent);\n        break;\n\n      default:\n        await this.manager.captureIntent({\n          address,\n          status,\n          btcAmount,\n          type: IntentType.Transaction,\n          assetType: AssetType.BTC,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n        } as BTCTransactionIntent);\n    }\n  }\n\n  private async txExists(tx: EsploraTransaction) {\n    const intents = await this.manager.retrieveIntentsByAddresses(\n      this.addresses\n    );\n    return !!intents.find((intent) => intent.transactionIds.includes(tx.txid));\n  }\n\n  private async getInscriptions(\n    tx: EsploraTransaction\n  ): Promise<Inscription[]> {\n    let inscriptions = await this.getTxOutputsInscriptions(tx);\n    if (inscriptions.length === 0) {\n      inscriptions = await this.getPrevOutputsInscriptions(tx);\n    }\n    if (inscriptions.length === 0) {\n      inscriptions = this.getInputInscriptions(tx);\n    }\n    if (inscriptions.length === 0) {\n      inscriptions = await this.getPrevInputsInscriptions(tx);\n    }\n\n    return inscriptions;\n  }\n\n  private async getTxOutputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    if (!tx.status.confirmed) {\n      return [];\n    }\n\n    const voutIndexes = tx.vout\n      .map((output, index) =>\n        this.addresses.includes(output.scriptpubkey_address) ? index : null\n      )\n      .filter((index) => index !== null);\n    const txOutputs = await Promise.all(\n      voutIndexes.map((voutIndex) =>\n        this.provider.getTxOutput(tx.txid, voutIndex)\n      )\n    );\n\n    const isIndexed =\n      txOutputs.length > 0 && txOutputs.every((output) => output.indexed);\n\n    if (isIndexed) {\n      return Promise.all(\n        inscriptionIdsFromTxOutputs(txOutputs).map((id) =>\n          this.provider.getInscriptionById(id)\n        )\n      );\n    }\n    return [];\n  }\n\n  private async getPrevOutputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    const txPrevOutputs = await Promise.all(\n      tx.vin.map(({ txid, vout }) => this.provider.getTxOutput(txid, vout))\n    );\n    return Promise.all(\n      inscriptionIdsFromTxOutputs(txPrevOutputs).map((id) =>\n        this.provider.getInscriptionById(id)\n      )\n    );\n  }\n\n  private getInputInscriptions(tx: EsploraTransaction): any[] {\n    return tx.vin.flatMap((input) => getInscriptionsFromInput(input, tx.txid));\n  }\n\n  private async getPrevInputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    const prevTxs = await Promise.all(\n      tx.vin.map((input) => this.provider.getTxById(input.txid))\n    );\n\n    const prevInputsInscriptions = prevTxs.flatMap((prevTx) =>\n      prevTx.vin.flatMap((input) =>\n        getInscriptionsFromInput(input, prevTx.txid)\n      )\n    );\n    return prevInputsInscriptions;\n  }\n\n  private categorizeInscriptions(\n    inscriptions: Inscription[]\n  ): CategorizedInscription[] {\n    const categorized: CategorizedInscription[] = [];\n\n    for (let inscription of inscriptions) {\n      const brc20 = parseBrc20Inscription(inscription);\n\n      if (brc20) {\n        categorized.push({\n          ...brc20,\n          assetType: AssetType.BRC20,\n        });\n      } else {\n        categorized.push({\n          ...inscription,\n          assetType: AssetType.COLLECTIBLE,\n        });\n      }\n    }\n\n    return categorized;\n  }\n}\n","import { IntentManager } from \"./IntentManager\";\nimport { TransactionHandler } from \"./handlers\";\nimport { IntentStatus, IntentType, RpcProvider } from \"./types\";\n\nexport class IntentSynchronizer {\n  private transactionHandler: TransactionHandler;\n\n  constructor(private manager: IntentManager, provider: RpcProvider) {\n    this.transactionHandler = new TransactionHandler(manager, provider);\n  }\n\n  async syncPendingIntents(addresses: string[]) {\n    const intents = await this.manager.retrievePendingIntentsByAddresses(\n      addresses\n    );\n    await Promise.all(\n      intents.map(async (intent) => {\n        if (intent.type === IntentType.Transaction) {\n          await this.transactionHandler.handlePendingTransaction(intent);\n        }\n      })\n    );\n  }\n\n  async syncIntentsFromChain(addresses: string[], syncFromTimestamp?: number) {\n    const intents = await this.manager\n      .retrieveIntentsByAddresses(addresses)\n      .then((intents) =>\n        intents.filter(({ status }) => status === IntentStatus.Pending)\n      );\n\n    if (intents.every(({ transactionIds }) => transactionIds.length > 0)) {\n      await this.transactionHandler.handleTransactions(\n        addresses,\n        syncFromTimestamp\n      );\n    }\n  }\n}\n","import { EventEmitter } from \"events\";\nimport {\n  CapturedIntent,\n  IntentHandler,\n  IntentStatus,\n  CapturableIntent,\n  StorageAdapter,\n  WalletIntent,\n} from \"./types\";\n\nexport class IntentManager extends EventEmitter implements IntentHandler {\n  constructor(private storage: StorageAdapter, public debug = false) {\n    super();\n  }\n\n  private notifyIntentCaptured(intent: CapturableIntent<WalletIntent>) {\n    this.emit(\"intentCaptured\", intent);\n  }\n\n  async captureIntent(\n    intent: CapturableIntent<WalletIntent>\n  ): Promise<CapturedIntent> {\n    if (this.debug) {\n      console.log(\"Capturing intent:\", intent);\n      return;\n    }\n\n    const capturedIntent = await this.storage.save(intent);\n\n    this.notifyIntentCaptured(capturedIntent);\n\n    const update = async (\n      updates: Partial<WalletIntent>\n    ): Promise<WalletIntent> => {\n      const updatedIntent = await this.storage.save({\n        ...capturedIntent,\n        ...updates,\n      });\n\n      this.notifyIntentCaptured(capturedIntent);\n\n      return updatedIntent;\n    };\n\n    return {\n      intent: capturedIntent,\n      update,\n    };\n  }\n\n  async retrieveAllIntents() {\n    return this.storage.findAll();\n  }\n\n  async retrievePendingIntentsByAddresses(addresses: string[]) {\n    return this.storage.findByStatusAndAddresses(\n      IntentStatus.Pending,\n      addresses\n    );\n  }\n\n  async retrieveIntentsByAddresses(addresses: string[]) {\n    return this.storage.findByAddresses(addresses);\n  }\n\n  async retrieveIntentById(intentId: string) {\n    return this.storage.findById(intentId);\n  }\n\n  onIntentCaptured(listener: (intent: WalletIntent) => void): void {\n    this.on(\"intentCaptured\", listener);\n  }\n}\n"],"mappings":"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","names":["IntentStatus","IntentType","TransactionType","AssetType","BRC20Operation","RuneOperation","uuidv4","import_uuid","uuidv4","intents"]}