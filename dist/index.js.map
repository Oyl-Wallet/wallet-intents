{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/adapters/InMemoryStorageAdapter.ts","../src/adapters/PlasmoStorageAdapter.ts","../src/providers/SandshrewRpcProvider.ts","../src/helpers.ts","../src/utils.ts","../src/handlers/TransactionHandler.ts","../src/IntentSynchronizer.ts","../src/IntentManager.ts"],"sourcesContent":["export * from \"./types\";\nexport * from \"./adapters\";\nexport * from \"./providers\";\nexport { IntentSynchronizer } from \"./IntentSynchronizer\";\nexport { IntentManager } from \"./IntentManager\";\n","export enum IntentStatus {\n  Pending = \"pending\",\n  Completed = \"completed\",\n  Failed = \"failed\",\n}\n\nexport enum IntentType {\n  Transaction = \"transaction\",\n}\n\nexport interface BaseIntent {\n  id: string;\n  timestamp: number;\n  address: string;\n  status: IntentStatus;\n}\n\nexport enum TransactionType {\n  Send = \"send\",\n  Receive = \"receive\",\n  Trade = \"trade\",\n}\n\nexport enum AssetType {\n  BTC = \"btc\",\n  BRC20 = \"brc-20\",\n  RUNE = \"rune\",\n  COLLECTIBLE = \"collectible\",\n}\n\nexport interface TransactionIntent extends BaseIntent {\n  type: IntentType.Transaction;\n  transactionType: TransactionType;\n  assetType: AssetType;\n  transactionIds: string[];\n  amount: number;\n}\n\nexport interface BTCTransactionIntent extends TransactionIntent {\n  assetType: AssetType.BTC;\n  amount: number;\n}\n\nexport interface BRC20TransactionIntent extends TransactionIntent {\n  assetType: AssetType.BRC20;\n  ticker: string;\n  operation: string;\n  max?: number;\n  limit?: number;\n}\n\nexport interface RuneTransactionIntent extends TransactionIntent {\n  assetType: AssetType.RUNE;\n  runeId: string;\n  runeName: string;\n}\n\nexport interface CollectibleTransactionIntent extends TransactionIntent {\n  assetType: AssetType.COLLECTIBLE;\n  inscriptionId: string;\n  contentType: string;\n  content: string;\n}\n\nexport interface TradeBRC20Intent extends TransactionIntent {\n  assetType: AssetType.BRC20;\n  transactionType: TransactionType.Trade;\n  ticker: string;\n}\n\nexport type WalletIntent =\n  | BTCTransactionIntent\n  | BRC20TransactionIntent\n  | RuneTransactionIntent\n  | CollectibleTransactionIntent\n  | TradeBRC20Intent; // Add other intent types here\n\nexport interface IntentHandler {\n  captureIntent(intent: WalletIntent): Promise<void>;\n  retrieveAllIntents(): Promise<WalletIntent[]>;\n  retrievePendingIntents(): Promise<WalletIntent[]>;\n  retrieveTransactionIntents(): Promise<WalletIntent[]>;\n  retrieveIntentsByAddresses(addresses: string[]): Promise<WalletIntent[]>;\n}\n\nexport interface IntentSynchronizer {\n  start(): Promise<void>;\n}\n\nexport interface StorageAdapter {\n  save(intent: WalletIntent): Promise<void>;\n  findAll(): Promise<WalletIntent[]>;\n  findByType(type: IntentType): Promise<WalletIntent[]>;\n  findByStatus(status: IntentStatus): Promise<WalletIntent[]>;\n  findByAddresses(addresses: string[]): Promise<WalletIntent[]>;\n}\n\nexport interface RpcProvider {\n  baseUrl: string;\n  getTxById(txId: string): Promise<EsploraTransaction>;\n  getAddressTxs(address: string): Promise<EsploraTransaction[]>;\n  getTxOutput(txId: string, index: number): Promise<OrdOutput>;\n  getInscriptionById(inscriptionId: string): Promise<OrdInscription>;\n}\n\nexport interface EsploraTransaction {\n  txid: string;\n  version: number;\n  locktime: number;\n  vin: {\n    txid: string;\n    vout: number;\n    prevout: {\n      scriptpubkey: string;\n      scriptpubkey_asm: string;\n      scriptpubkey_type: string;\n      scriptpubkey_address: string;\n      value: number;\n    };\n    scriptsig: string;\n    scriptsig_asm: string;\n    witness: string[];\n    is_coinbase: boolean;\n    sequence: number;\n  }[];\n  vout: {\n    scriptpubkey: string;\n    scriptpubkey_asm: string;\n    scriptpubkey_type: string;\n    scriptpubkey_address: string;\n    value: number;\n  }[];\n  size: number;\n  weight: number;\n  fee: number;\n  status: {\n    confirmed: boolean;\n    block_height?: number;\n    block_hash?: string;\n    block_time?: number;\n  };\n}\n\nexport interface OrdOutput {\n  address: string;\n  indexed: boolean;\n  inscriptions: string[];\n  runes: any[];\n  sat_ranges: number[][];\n  script_pubkey: string;\n  spent: boolean;\n  transaction: string;\n  value: number;\n}\n\nexport type OrdInscription = {\n  content_type: string;\n  content: string;\n};\n\nexport type Inscription = {\n  id: string;\n  content_type: string;\n  content: string;\n};\n\nexport interface ParsedBRC20 {\n  p: string;\n  op: string;\n  amt: string;\n  tick: string;\n  max?: string;\n  lim?: string;\n}\n\nexport interface CollectibleAsset extends Inscription {\n  assetType: AssetType.COLLECTIBLE;\n}\n\nexport interface Brc20Asset extends ParsedBRC20 {\n  assetType: AssetType.BRC20;\n}\n\nexport type RuneAsset = {\n  assetType: AssetType.RUNE;\n};\n\nexport type CategorizedAsset = RuneAsset | Brc20Asset | CollectibleAsset;\n","import {\n  IntentStatus,\n  IntentType,\n  StorageAdapter,\n  WalletIntent,\n} from \"../types\";\n\nexport class InMemoryStorageAdapter implements StorageAdapter {\n  private intents: WalletIntent[] = [];\n\n  async save(intent: WalletIntent): Promise<void> {\n    if (intent.id) {\n      const newIntents = this.intents.map((existingIntent) => {\n        if (existingIntent.id === intent.id) {\n          return structuredClone({\n            ...existingIntent,\n            ...intent,\n          });\n        }\n        return existingIntent;\n      });\n\n      this.intents = newIntents;\n    } else {\n      this.intents.push(\n        structuredClone({\n          ...intent,\n          id: Math.random().toString(36).substring(7),\n          timestamp: Date.now(),\n        })\n      );\n    }\n  }\n\n  async findAll(): Promise<WalletIntent[]> {\n    return structuredClone(this.intents);\n  }\n\n  async findByType(type: IntentType): Promise<WalletIntent[]> {\n    return structuredClone(\n      this.intents.filter((intent) => intent.type === type)\n    );\n  }\n\n  async findByStatus(status: IntentStatus): Promise<WalletIntent[]> {\n    return structuredClone(\n      this.intents.filter((intent) => intent.status === status)\n    );\n  }\n\n  async findByAddresses(addresses: string[]): Promise<WalletIntent[]> {\n    return structuredClone(\n      this.intents.filter((intent) => addresses.includes(intent.address))\n    );\n  }\n}\n","import {\n  WalletIntent,\n  IntentStatus,\n  IntentType,\n  StorageAdapter,\n} from \"../types\";\nimport { Storage } from \"@plasmohq/storage\";\n\nexport class PlasmoStorageAdapter implements StorageAdapter {\n  private storage: Storage;\n  private key: string;\n\n  constructor(key: string) {\n    this.key = key;\n    this.storage = new Storage({\n      area: \"local\",\n    });\n  }\n\n  async save(intent: WalletIntent): Promise<void> {\n    const intents = await this.findAll();\n\n    if (intent.id) {\n      const newIntents = intents.map((existingIntent) => {\n        if (existingIntent.id === intent.id) {\n          return {\n            ...existingIntent,\n            ...intent,\n          };\n        }\n        return existingIntent;\n      });\n\n      return this.storage.set(this.key, newIntents);\n    } else {\n      intents.push(\n        structuredClone({\n          ...intent,\n          id: Math.random().toString(36).substring(7),\n          timestamp: Date.now(),\n        })\n      );\n\n      return this.storage.set(this.key, intents);\n    }\n  }\n\n  async findAll(): Promise<WalletIntent[]> {\n    return this.storage\n      .get<WalletIntent[]>(this.key)\n      .then((intents) => intents || []);\n  }\n\n  async findByType(type: IntentType): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.type === type)\n    );\n  }\n\n  async findByStatus(status: IntentStatus): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.status === status)\n    );\n  }\n\n  async findByAddresses(addresses: string[]): Promise<WalletIntent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => addresses.includes(intent.address))\n    );\n  }\n}\n","import {\n  RpcProvider,\n  EsploraTransaction,\n  OrdInscription,\n  OrdOutput,\n} from \"../types\";\n\nexport class SandshrewRpcProvider implements RpcProvider {\n  baseUrl: string;\n\n  constructor({ network, projectId }: { network: string; projectId: string }) {\n    if (network === \"regtest\") {\n      this.baseUrl = \"http://localhost:3000/v1/regtest\";\n    } else {\n      this.baseUrl = `https://${network}.sandshrew.io/v1/${projectId}`;\n    }\n  }\n\n  async getAddressTxs(address: string): Promise<EsploraTransaction[]> {\n    try {\n      const response = await fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"esplora_address::txs\",\n          params: [address],\n        }),\n      });\n\n      const data = await response.json();\n      return data.result;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async getTxById(txId: string): Promise<EsploraTransaction> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"esplora_tx\",\n        params: [txId],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n\n  async getTxOutput(txId: string, voutIndex: number): Promise<OrdOutput> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"ord_output\",\n        params: [`${txId}:${voutIndex}`],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n\n  async getInscriptionById(inscriptionId: string): Promise<OrdInscription> {\n    const [inscriptionResponse, contentResponse] = await Promise.all([\n      fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"ord_inscription\",\n          params: [inscriptionId],\n        }),\n      }),\n      fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"ord_content\",\n          params: [inscriptionId],\n        }),\n      }),\n    ]);\n\n    const inscriptionData = await inscriptionResponse.json();\n    const contentData = await contentResponse.json();\n\n    return {\n      ...inscriptionData.result,\n      content: contentData.result,\n    };\n  }\n}\n","import { parseWitness } from \"micro-ordinals\";\nimport {\n  ParsedBRC20,\n  EsploraTransaction,\n  Inscription,\n  WalletIntent,\n} from \"./types\";\n\nexport function isReceiveTx(tx: EsploraTransaction, addresses: string[]) {\n  const outputsToAddress = tx.vout.filter((output) =>\n    addresses.includes(output.scriptpubkey_address)\n  );\n  const inputsFromAddress = tx.vin.some((input) =>\n    addresses.includes(input.prevout.scriptpubkey_address)\n  );\n\n  return outputsToAddress.length > 0 && !inputsFromAddress;\n}\n\nexport function txIntentExists(\n  tx: EsploraTransaction,\n  intents: WalletIntent[]\n) {\n  return intents.some((intent) => intent.transactionIds.includes(tx.txid));\n}\n\nexport function determineReceiverAddress(\n  tx: EsploraTransaction,\n  addresses: string[]\n) {\n  for (const output of tx.vout) {\n    if (addresses.includes(output.scriptpubkey_address)) {\n      return output.scriptpubkey_address;\n    }\n  }\n}\n\nexport function determineReceiverAmount(\n  tx: EsploraTransaction,\n  addresses: string[]\n) {\n  let amount = 0;\n\n  for (const output of tx.vout) {\n    if (addresses.includes(output.scriptpubkey_address)) {\n      amount += output.value;\n    }\n  }\n\n  return amount;\n}\n\nexport function inscriptionIdsFromTxOutputs(txOutputs) {\n  let inscriptionIds = [];\n  for (let output of txOutputs) {\n    inscriptionIds = inscriptionIds.concat(output.inscriptions);\n  }\n\n  return inscriptionIds;\n}\n\nexport function getInscriptionsFromInput(input: {\n  txid: string;\n  witness: string[];\n}) {\n  if (input.witness.length < 3) return [];\n\n  const inscriptions = [];\n\n  const parsedInscriptions = parseWitness(\n    input.witness.map((witness) => Uint8Array.from(Buffer.from(witness, \"hex\")))\n  );\n\n  for (let inscription of parsedInscriptions) {\n    inscriptions.push({\n      id: `${input.txid}i0`,\n      content_type: inscription.tags.contentType,\n      content: uint8ArrayToBase64(inscription.body),\n    });\n  }\n\n  return inscriptions;\n}\n\nexport function uint8ArrayToBase64(uint8Array: Uint8Array) {\n  let binaryString = \"\";\n  const len = uint8Array.byteLength;\n  for (let i = 0; i < len; i++) {\n    binaryString += String.fromCharCode(uint8Array[i]);\n  }\n  return btoa(binaryString);\n}\n\nexport function parseBrc20Inscription(\n  inscription: Inscription\n): ParsedBRC20 | void {\n  const contentBuffer = Buffer.from(inscription.content, \"base64\");\n  try {\n    let parsed = JSON.parse(contentBuffer.toString());\n    if (parsed.p === \"brc-20\") {\n      return parsed;\n    }\n  } catch {}\n}\n","export function parseNumber(value: string): number | null {\n  const parsed = parseFloat(value);\n  return isNaN(parsed) ? null : parsed;\n}\n","import { IntentManager } from \"../IntentManager\";\nimport {\n  parseBrc20Inscription,\n  determineReceiverAddress,\n  getInscriptionsFromInput,\n  inscriptionIdsFromTxOutputs,\n  isReceiveTx,\n  txIntentExists,\n  determineReceiverAmount,\n} from \"../helpers\";\nimport {\n  IntentStatus,\n  EsploraTransaction,\n  Inscription,\n  RpcProvider,\n  WalletIntent,\n  IntentType,\n  CategorizedAsset,\n  AssetType,\n  TransactionType,\n  BRC20TransactionIntent,\n  CollectibleTransactionIntent,\n  BTCTransactionIntent,\n} from \"../types\";\nimport { parseNumber } from \"../utils\";\n\nexport class TransactionHandler {\n  private addresses: string[] = [];\n\n  constructor(private manager: IntentManager, private provider: RpcProvider) {}\n\n  async setAddresses(addresses: string[]) {\n    this.addresses = addresses;\n  }\n\n  async handlePendingTransaction(intent: WalletIntent) {\n    const txs = await Promise.all(\n      intent.transactionIds.map((txId: string) => this.provider.getTxById(txId))\n    );\n\n    if (txs.every((tx: EsploraTransaction) => tx.status.confirmed)) {\n      intent.status = IntentStatus.Completed;\n      await this.manager.captureIntent(intent);\n    }\n  }\n\n  async handleReceivedTransactions(addresses: string[]) {\n    this.addresses = addresses;\n\n    const intents = await this.manager.retrieveIntentsByAddresses(\n      this.addresses\n    );\n\n    if (intents.some(({ transactionIds }) => transactionIds.length === 0))\n      return;\n\n    const txs = (\n      await Promise.all(\n        this.addresses.map((addr) => this.provider.getAddressTxs(addr))\n      )\n    ).flat();\n    for (let tx of txs) {\n      if (!isReceiveTx(tx, this.addresses) || txIntentExists(tx, intents))\n        continue;\n      await this.processReceiveTransaction(tx);\n    }\n  }\n\n  private async processReceiveTransaction(tx: EsploraTransaction) {\n    const inscriptions = await this.getInscriptions(tx);\n\n    const categorizedAssets = this.categorizeInscriptions(inscriptions);\n\n    const [asset] = categorizedAssets;\n\n    const address = determineReceiverAddress(tx, this.addresses);\n    const status = tx.status.confirmed\n      ? IntentStatus.Completed\n      : IntentStatus.Pending;\n    const amount = determineReceiverAmount(tx, this.addresses);\n\n    switch (asset?.assetType) {\n      case AssetType.BRC20:\n        await this.manager.captureIntent({\n          address,\n          status,\n          type: IntentType.Transaction,\n          assetType: AssetType.BRC20,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          ticker: asset.tick,\n          operation: asset.op,\n          amount: parseNumber(asset.amt) || amount,\n          max: parseNumber(asset.max),\n          limit: parseNumber(asset.lim),\n        } as BRC20TransactionIntent);\n        break;\n\n      case AssetType.COLLECTIBLE:\n        await this.manager.captureIntent({\n          address,\n          status,\n          amount,\n          type: IntentType.Transaction,\n          assetType: AssetType.COLLECTIBLE,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n          inscriptionId: asset.id,\n          contentType: asset.content_type,\n          content: asset.content,\n        } as CollectibleTransactionIntent);\n        break;\n\n      default:\n        await this.manager.captureIntent({\n          address,\n          status,\n          amount,\n          type: IntentType.Transaction,\n          assetType: AssetType.BTC,\n          transactionType: TransactionType.Receive,\n          transactionIds: [tx.txid],\n        } as BTCTransactionIntent);\n    }\n  }\n\n  private async getInscriptions(tx: EsploraTransaction): Promise<any[]> {\n    let inscriptions = await this.getTxOutputsInscriptions(tx);\n    if (inscriptions.length === 0) {\n      inscriptions = await this.getPrevOutputsInscriptions(tx);\n    }\n    if (inscriptions.length === 0) {\n      inscriptions = this.getInputInscriptions(tx);\n    }\n    return inscriptions;\n  }\n\n  private async getTxOutputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    const voutIndexes = tx.vout\n      .map((output, index) =>\n        this.addresses.includes(output.scriptpubkey_address) ? index : null\n      )\n      .filter((index) => index !== null);\n    const txOutputs = await Promise.all(\n      voutIndexes.map((voutIndex) =>\n        this.provider.getTxOutput(tx.txid, voutIndex)\n      )\n    );\n\n    if (txOutputs.every((output) => output.indexed)) {\n      return Promise.all(\n        inscriptionIdsFromTxOutputs(txOutputs).map((id) =>\n          this.provider.getInscriptionById(id)\n        )\n      );\n    }\n    return [];\n  }\n\n  private async getPrevOutputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    const txPrevOutputs = await Promise.all(\n      tx.vin.map(({ txid, vout }) => this.provider.getTxOutput(txid, vout))\n    );\n    return Promise.all(\n      inscriptionIdsFromTxOutputs(txPrevOutputs).map((id) =>\n        this.provider.getInscriptionById(id)\n      )\n    );\n  }\n\n  private getInputInscriptions(tx: EsploraTransaction): any[] {\n    return tx.vin.flatMap((input) => getInscriptionsFromInput(input));\n  }\n\n  private categorizeInscriptions(\n    inscriptions: Inscription[]\n  ): CategorizedAsset[] {\n    const assets: CategorizedAsset[] = [];\n\n    for (let inscription of inscriptions) {\n      const brc20 = parseBrc20Inscription(inscription);\n\n      if (brc20) {\n        assets.push({\n          ...brc20,\n          assetType: AssetType.BRC20,\n        });\n      } else {\n        assets.push({\n          ...inscription,\n          assetType: AssetType.COLLECTIBLE,\n        });\n      }\n    }\n    return assets;\n  }\n}\n","import { IntentManager } from \"./IntentManager\";\nimport { TransactionHandler } from \"./handlers\";\nimport { IntentType, RpcProvider } from \"./types\";\n\nexport class IntentSynchronizer {\n  private transactionHandler: TransactionHandler;\n\n  constructor(private manager: IntentManager, provider: RpcProvider) {\n    this.transactionHandler = new TransactionHandler(manager, provider);\n  }\n\n  async syncPendingIntents() {\n    const pendingIntents = await this.manager.retrievePendingIntents();\n    await Promise.all(\n      pendingIntents.map(async (intent) => {\n        if (intent.type === IntentType.Transaction) {\n          await this.transactionHandler.handlePendingTransaction(intent);\n        }\n      })\n    );\n  }\n\n  async syncReceivedTxIntents(addresses: string[]) {\n    const intents = await this.manager.retrieveTransactionIntents();\n    if (intents.every(({ transactionIds }) => transactionIds.length > 0)) {\n      await this.transactionHandler.handleReceivedTransactions(addresses);\n    }\n  }\n}\n","import {\n  IntentHandler,\n  IntentStatus,\n  IntentType,\n  StorageAdapter,\n  WalletIntent,\n} from \"./types\";\n\nexport class IntentManager implements IntentHandler {\n  constructor(\n    private storage: StorageAdapter,\n    private addresses: string[] = []\n  ) {}\n\n  async captureIntent(\n    intent: Omit<WalletIntent, \"id\" | \"timestamp\">\n  ): Promise<void> {\n    await this.storage.save(intent as WalletIntent);\n  }\n\n  async retrieveAllIntents(): Promise<WalletIntent[]> {\n    return this.storage.findAll();\n  }\n\n  async retrievePendingIntents(): Promise<WalletIntent[]> {\n    const intents = await this.retrieveAllIntents();\n    return intents.filter((intent) => intent.status === IntentStatus.Pending);\n  }\n\n  async retrieveIntentsByAddresses(\n    addresses: string[]\n  ): Promise<WalletIntent[]> {\n    return this.storage.findByAddresses(addresses);\n  }\n\n  async retrieveTransactionIntents(): Promise<WalletIntent[]> {\n    const intents = await this.retrieveAllIntents();\n    return intents.filter((intent) => intent.type === IntentType.Transaction);\n  }\n\n  async getAddresses(): Promise<string[]> {\n    return this.addresses;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAK,eAAL,kBAAKA,kBAAL;AACL,EAAAA,cAAA,aAAU;AACV,EAAAA,cAAA,eAAY;AACZ,EAAAA,cAAA,YAAS;AAHC,SAAAA;AAAA,GAAA;AAML,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,YAAA,iBAAc;AADJ,SAAAA;AAAA,GAAA;AAWL,IAAK,kBAAL,kBAAKC,qBAAL;AACL,EAAAA,iBAAA,UAAO;AACP,EAAAA,iBAAA,aAAU;AACV,EAAAA,iBAAA,WAAQ;AAHE,SAAAA;AAAA,GAAA;AAML,IAAK,YAAL,kBAAKC,eAAL;AACL,EAAAA,WAAA,SAAM;AACN,EAAAA,WAAA,WAAQ;AACR,EAAAA,WAAA,UAAO;AACP,EAAAA,WAAA,iBAAc;AAJJ,SAAAA;AAAA,GAAA;;;AChBL,IAAM,yBAAN,MAAuD;AAAA,EACpD,UAA0B,CAAC;AAAA,EAEnC,MAAM,KAAK,QAAqC;AAC9C,QAAI,OAAO,IAAI;AACb,YAAM,aAAa,KAAK,QAAQ,IAAI,CAAC,mBAAmB;AACtD,YAAI,eAAe,OAAO,OAAO,IAAI;AACnC,iBAAO,gBAAgB;AAAA,YACrB,GAAG;AAAA,YACH,GAAG;AAAA,UACL,CAAC;AAAA,QACH;AACA,eAAO;AAAA,MACT,CAAC;AAED,WAAK,UAAU;AAAA,IACjB,OAAO;AACL,WAAK,QAAQ;AAAA,QACX,gBAAgB;AAAA,UACd,GAAG;AAAA,UACH,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,CAAC;AAAA,UAC1C,WAAW,KAAK,IAAI;AAAA,QACtB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,UAAmC;AACvC,WAAO,gBAAgB,KAAK,OAAO;AAAA,EACrC;AAAA,EAEA,MAAM,WAAW,MAA2C;AAC1D,WAAO;AAAA,MACL,KAAK,QAAQ,OAAO,CAAC,WAAW,OAAO,SAAS,IAAI;AAAA,IACtD;AAAA,EACF;AAAA,EAEA,MAAM,aAAa,QAA+C;AAChE,WAAO;AAAA,MACL,KAAK,QAAQ,OAAO,CAAC,WAAW,OAAO,WAAW,MAAM;AAAA,IAC1D;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB,WAA8C;AAClE,WAAO;AAAA,MACL,KAAK,QAAQ,OAAO,CAAC,WAAW,UAAU,SAAS,OAAO,OAAO,CAAC;AAAA,IACpE;AAAA,EACF;AACF;;;ACjDA,qBAAwB;AAEjB,IAAM,uBAAN,MAAqD;AAAA,EAClD;AAAA,EACA;AAAA,EAER,YAAY,KAAa;AACvB,SAAK,MAAM;AACX,SAAK,UAAU,IAAI,uBAAQ;AAAA,MACzB,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,KAAK,QAAqC;AAC9C,UAAM,UAAU,MAAM,KAAK,QAAQ;AAEnC,QAAI,OAAO,IAAI;AACb,YAAM,aAAa,QAAQ,IAAI,CAAC,mBAAmB;AACjD,YAAI,eAAe,OAAO,OAAO,IAAI;AACnC,iBAAO;AAAA,YACL,GAAG;AAAA,YACH,GAAG;AAAA,UACL;AAAA,QACF;AACA,eAAO;AAAA,MACT,CAAC;AAED,aAAO,KAAK,QAAQ,IAAI,KAAK,KAAK,UAAU;AAAA,IAC9C,OAAO;AACL,cAAQ;AAAA,QACN,gBAAgB;AAAA,UACd,GAAG;AAAA,UACH,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,CAAC;AAAA,UAC1C,WAAW,KAAK,IAAI;AAAA,QACtB,CAAC;AAAA,MACH;AAEA,aAAO,KAAK,QAAQ,IAAI,KAAK,KAAK,OAAO;AAAA,IAC3C;AAAA,EACF;AAAA,EAEA,MAAM,UAAmC;AACvC,WAAO,KAAK,QACT,IAAoB,KAAK,GAAG,EAC5B,KAAK,CAAC,YAAY,WAAW,CAAC,CAAC;AAAA,EACpC;AAAA,EAEA,MAAM,WAAW,MAA2C;AAC1D,WAAO,KAAK,QAAQ,EAAE;AAAA,MAAK,CAAC,YAC1B,QAAQ,OAAO,CAAC,WAAW,OAAO,SAAS,IAAI;AAAA,IACjD;AAAA,EACF;AAAA,EAEA,MAAM,aAAa,QAA+C;AAChE,WAAO,KAAK,QAAQ,EAAE;AAAA,MAAK,CAAC,YAC1B,QAAQ,OAAO,CAAC,WAAW,OAAO,WAAW,MAAM;AAAA,IACrD;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB,WAA8C;AAClE,WAAO,KAAK,QAAQ,EAAE;AAAA,MAAK,CAAC,YAC1B,QAAQ,OAAO,CAAC,WAAW,UAAU,SAAS,OAAO,OAAO,CAAC;AAAA,IAC/D;AAAA,EACF;AACF;;;AC/DO,IAAM,uBAAN,MAAkD;AAAA,EACvD;AAAA,EAEA,YAAY,EAAE,SAAS,UAAU,GAA2C;AAC1E,QAAI,YAAY,WAAW;AACzB,WAAK,UAAU;AAAA,IACjB,OAAO;AACL,WAAK,UAAU,WAAW,OAAO,oBAAoB,SAAS;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,MAAM,cAAc,SAAgD;AAClE,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK,SAAS;AAAA,QACzC,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU;AAAA,UACnB,SAAS;AAAA,UACT,IAAI;AAAA,UACJ,QAAQ;AAAA,UACR,QAAQ,CAAC,OAAO;AAAA,QAClB,CAAC;AAAA,MACH,CAAC;AAED,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO,KAAK;AAAA,IACd,SAAS,OAAO;AACd,cAAQ,MAAM,KAAK;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAM,UAAU,MAA2C;AACzD,UAAM,WAAW,MAAM,MAAM,KAAK,SAAS;AAAA,MACzC,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAC9C,MAAM,KAAK,UAAU;AAAA,QACnB,SAAS;AAAA,QACT,IAAI;AAAA,QACJ,QAAQ;AAAA,QACR,QAAQ,CAAC,IAAI;AAAA,MACf,CAAC;AAAA,IACH,CAAC;AAED,UAAM,OAAO,MAAM,SAAS,KAAK;AACjC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,YAAY,MAAc,WAAuC;AACrE,UAAM,WAAW,MAAM,MAAM,KAAK,SAAS;AAAA,MACzC,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAC9C,MAAM,KAAK,UAAU;AAAA,QACnB,SAAS;AAAA,QACT,IAAI;AAAA,QACJ,QAAQ;AAAA,QACR,QAAQ,CAAC,GAAG,IAAI,IAAI,SAAS,EAAE;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,UAAM,OAAO,MAAM,SAAS,KAAK;AACjC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,mBAAmB,eAAgD;AACvE,UAAM,CAAC,qBAAqB,eAAe,IAAI,MAAM,QAAQ,IAAI;AAAA,MAC/D,MAAM,KAAK,SAAS;AAAA,QAClB,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU;AAAA,UACnB,SAAS;AAAA,UACT,IAAI;AAAA,UACJ,QAAQ;AAAA,UACR,QAAQ,CAAC,aAAa;AAAA,QACxB,CAAC;AAAA,MACH,CAAC;AAAA,MACD,MAAM,KAAK,SAAS;AAAA,QAClB,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAC9C,MAAM,KAAK,UAAU;AAAA,UACnB,SAAS;AAAA,UACT,IAAI;AAAA,UACJ,QAAQ;AAAA,UACR,QAAQ,CAAC,aAAa;AAAA,QACxB,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAED,UAAM,kBAAkB,MAAM,oBAAoB,KAAK;AACvD,UAAM,cAAc,MAAM,gBAAgB,KAAK;AAE/C,WAAO;AAAA,MACL,GAAG,gBAAgB;AAAA,MACnB,SAAS,YAAY;AAAA,IACvB;AAAA,EACF;AACF;;;ACtGA,4BAA6B;AAQtB,SAAS,YAAY,IAAwB,WAAqB;AACvE,QAAM,mBAAmB,GAAG,KAAK;AAAA,IAAO,CAAC,WACvC,UAAU,SAAS,OAAO,oBAAoB;AAAA,EAChD;AACA,QAAM,oBAAoB,GAAG,IAAI;AAAA,IAAK,CAAC,UACrC,UAAU,SAAS,MAAM,QAAQ,oBAAoB;AAAA,EACvD;AAEA,SAAO,iBAAiB,SAAS,KAAK,CAAC;AACzC;AAEO,SAAS,eACd,IACA,SACA;AACA,SAAO,QAAQ,KAAK,CAAC,WAAW,OAAO,eAAe,SAAS,GAAG,IAAI,CAAC;AACzE;AAEO,SAAS,yBACd,IACA,WACA;AACA,aAAW,UAAU,GAAG,MAAM;AAC5B,QAAI,UAAU,SAAS,OAAO,oBAAoB,GAAG;AACnD,aAAO,OAAO;AAAA,IAChB;AAAA,EACF;AACF;AAEO,SAAS,wBACd,IACA,WACA;AACA,MAAI,SAAS;AAEb,aAAW,UAAU,GAAG,MAAM;AAC5B,QAAI,UAAU,SAAS,OAAO,oBAAoB,GAAG;AACnD,gBAAU,OAAO;AAAA,IACnB;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,4BAA4B,WAAW;AACrD,MAAI,iBAAiB,CAAC;AACtB,WAAS,UAAU,WAAW;AAC5B,qBAAiB,eAAe,OAAO,OAAO,YAAY;AAAA,EAC5D;AAEA,SAAO;AACT;AAEO,SAAS,yBAAyB,OAGtC;AACD,MAAI,MAAM,QAAQ,SAAS;AAAG,WAAO,CAAC;AAEtC,QAAM,eAAe,CAAC;AAEtB,QAAM,yBAAqB;AAAA,IACzB,MAAM,QAAQ,IAAI,CAAC,YAAY,WAAW,KAAK,OAAO,KAAK,SAAS,KAAK,CAAC,CAAC;AAAA,EAC7E;AAEA,WAAS,eAAe,oBAAoB;AAC1C,iBAAa,KAAK;AAAA,MAChB,IAAI,GAAG,MAAM,IAAI;AAAA,MACjB,cAAc,YAAY,KAAK;AAAA,MAC/B,SAAS,mBAAmB,YAAY,IAAI;AAAA,IAC9C,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEO,SAAS,mBAAmB,YAAwB;AACzD,MAAI,eAAe;AACnB,QAAM,MAAM,WAAW;AACvB,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,oBAAgB,OAAO,aAAa,WAAW,CAAC,CAAC;AAAA,EACnD;AACA,SAAO,KAAK,YAAY;AAC1B;AAEO,SAAS,sBACd,aACoB;AACpB,QAAM,gBAAgB,OAAO,KAAK,YAAY,SAAS,QAAQ;AAC/D,MAAI;AACF,QAAI,SAAS,KAAK,MAAM,cAAc,SAAS,CAAC;AAChD,QAAI,OAAO,MAAM,UAAU;AACzB,aAAO;AAAA,IACT;AAAA,EACF,QAAQ;AAAA,EAAC;AACX;;;ACvGO,SAAS,YAAY,OAA8B;AACxD,QAAM,SAAS,WAAW,KAAK;AAC/B,SAAO,MAAM,MAAM,IAAI,OAAO;AAChC;;;ACuBO,IAAM,qBAAN,MAAyB;AAAA,EAG9B,YAAoB,SAAgC,UAAuB;AAAvD;AAAgC;AAAA,EAAwB;AAAA,EAFpE,YAAsB,CAAC;AAAA,EAI/B,MAAM,aAAa,WAAqB;AACtC,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,MAAM,yBAAyB,QAAsB;AACnD,UAAM,MAAM,MAAM,QAAQ;AAAA,MACxB,OAAO,eAAe,IAAI,CAAC,SAAiB,KAAK,SAAS,UAAU,IAAI,CAAC;AAAA,IAC3E;AAEA,QAAI,IAAI,MAAM,CAAC,OAA2B,GAAG,OAAO,SAAS,GAAG;AAC9D,aAAO;AACP,YAAM,KAAK,QAAQ,cAAc,MAAM;AAAA,IACzC;AAAA,EACF;AAAA,EAEA,MAAM,2BAA2B,WAAqB;AACpD,SAAK,YAAY;AAEjB,UAAM,UAAU,MAAM,KAAK,QAAQ;AAAA,MACjC,KAAK;AAAA,IACP;AAEA,QAAI,QAAQ,KAAK,CAAC,EAAE,eAAe,MAAM,eAAe,WAAW,CAAC;AAClE;AAEF,UAAM,OACJ,MAAM,QAAQ;AAAA,MACZ,KAAK,UAAU,IAAI,CAAC,SAAS,KAAK,SAAS,cAAc,IAAI,CAAC;AAAA,IAChE,GACA,KAAK;AACP,aAAS,MAAM,KAAK;AAClB,UAAI,CAAC,YAAY,IAAI,KAAK,SAAS,KAAK,eAAe,IAAI,OAAO;AAChE;AACF,YAAM,KAAK,0BAA0B,EAAE;AAAA,IACzC;AAAA,EACF;AAAA,EAEA,MAAc,0BAA0B,IAAwB;AAC9D,UAAM,eAAe,MAAM,KAAK,gBAAgB,EAAE;AAElD,UAAM,oBAAoB,KAAK,uBAAuB,YAAY;AAElE,UAAM,CAAC,KAAK,IAAI;AAEhB,UAAM,UAAU,yBAAyB,IAAI,KAAK,SAAS;AAC3D,UAAM,SAAS,GAAG,OAAO;AAGzB,UAAM,SAAS,wBAAwB,IAAI,KAAK,SAAS;AAEzD,YAAQ,OAAO,WAAW;AAAA,MACxB;AACE,cAAM,KAAK,QAAQ,cAAc;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,gBAAgB,CAAC,GAAG,IAAI;AAAA,UACxB,QAAQ,MAAM;AAAA,UACd,WAAW,MAAM;AAAA,UACjB,QAAQ,YAAY,MAAM,GAAG,KAAK;AAAA,UAClC,KAAK,YAAY,MAAM,GAAG;AAAA,UAC1B,OAAO,YAAY,MAAM,GAAG;AAAA,QAC9B,CAA2B;AAC3B;AAAA,MAEF;AACE,cAAM,KAAK,QAAQ,cAAc;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,gBAAgB,CAAC,GAAG,IAAI;AAAA,UACxB,eAAe,MAAM;AAAA,UACrB,aAAa,MAAM;AAAA,UACnB,SAAS,MAAM;AAAA,QACjB,CAAiC;AACjC;AAAA,MAEF;AACE,cAAM,KAAK,QAAQ,cAAc;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,gBAAgB,CAAC,GAAG,IAAI;AAAA,QAC1B,CAAyB;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,MAAc,gBAAgB,IAAwC;AACpE,QAAI,eAAe,MAAM,KAAK,yBAAyB,EAAE;AACzD,QAAI,aAAa,WAAW,GAAG;AAC7B,qBAAe,MAAM,KAAK,2BAA2B,EAAE;AAAA,IACzD;AACA,QAAI,aAAa,WAAW,GAAG;AAC7B,qBAAe,KAAK,qBAAqB,EAAE;AAAA,IAC7C;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,yBACZ,IACgB;AAChB,UAAM,cAAc,GAAG,KACpB;AAAA,MAAI,CAAC,QAAQ,UACZ,KAAK,UAAU,SAAS,OAAO,oBAAoB,IAAI,QAAQ;AAAA,IACjE,EACC,OAAO,CAAC,UAAU,UAAU,IAAI;AACnC,UAAM,YAAY,MAAM,QAAQ;AAAA,MAC9B,YAAY;AAAA,QAAI,CAAC,cACf,KAAK,SAAS,YAAY,GAAG,MAAM,SAAS;AAAA,MAC9C;AAAA,IACF;AAEA,QAAI,UAAU,MAAM,CAAC,WAAW,OAAO,OAAO,GAAG;AAC/C,aAAO,QAAQ;AAAA,QACb,4BAA4B,SAAS,EAAE;AAAA,UAAI,CAAC,OAC1C,KAAK,SAAS,mBAAmB,EAAE;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AAAA,EAEA,MAAc,2BACZ,IACgB;AAChB,UAAM,gBAAgB,MAAM,QAAQ;AAAA,MAClC,GAAG,IAAI,IAAI,CAAC,EAAE,MAAM,KAAK,MAAM,KAAK,SAAS,YAAY,MAAM,IAAI,CAAC;AAAA,IACtE;AACA,WAAO,QAAQ;AAAA,MACb,4BAA4B,aAAa,EAAE;AAAA,QAAI,CAAC,OAC9C,KAAK,SAAS,mBAAmB,EAAE;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,qBAAqB,IAA+B;AAC1D,WAAO,GAAG,IAAI,QAAQ,CAAC,UAAU,yBAAyB,KAAK,CAAC;AAAA,EAClE;AAAA,EAEQ,uBACN,cACoB;AACpB,UAAM,SAA6B,CAAC;AAEpC,aAAS,eAAe,cAAc;AACpC,YAAM,QAAQ,sBAAsB,WAAW;AAE/C,UAAI,OAAO;AACT,eAAO,KAAK;AAAA,UACV,GAAG;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AACL,eAAO,KAAK;AAAA,UACV,GAAG;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;;;ACpMO,IAAM,qBAAN,MAAyB;AAAA,EAG9B,YAAoB,SAAwB,UAAuB;AAA/C;AAClB,SAAK,qBAAqB,IAAI,mBAAmB,SAAS,QAAQ;AAAA,EACpE;AAAA,EAJQ;AAAA,EAMR,MAAM,qBAAqB;AACzB,UAAM,iBAAiB,MAAM,KAAK,QAAQ,uBAAuB;AACjE,UAAM,QAAQ;AAAA,MACZ,eAAe,IAAI,OAAO,WAAW;AACnC,YAAI,OAAO,0CAAiC;AAC1C,gBAAM,KAAK,mBAAmB,yBAAyB,MAAM;AAAA,QAC/D;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAM,sBAAsB,WAAqB;AAC/C,UAAM,UAAU,MAAM,KAAK,QAAQ,2BAA2B;AAC9D,QAAI,QAAQ,MAAM,CAAC,EAAE,eAAe,MAAM,eAAe,SAAS,CAAC,GAAG;AACpE,YAAM,KAAK,mBAAmB,2BAA2B,SAAS;AAAA,IACpE;AAAA,EACF;AACF;;;ACpBO,IAAM,gBAAN,MAA6C;AAAA,EAClD,YACU,SACA,YAAsB,CAAC,GAC/B;AAFQ;AACA;AAAA,EACP;AAAA,EAEH,MAAM,cACJ,QACe;AACf,UAAM,KAAK,QAAQ,KAAK,MAAsB;AAAA,EAChD;AAAA,EAEA,MAAM,qBAA8C;AAClD,WAAO,KAAK,QAAQ,QAAQ;AAAA,EAC9B;AAAA,EAEA,MAAM,yBAAkD;AACtD,UAAM,UAAU,MAAM,KAAK,mBAAmB;AAC9C,WAAO,QAAQ,OAAO,CAAC,WAAW,OAAO,kCAA+B;AAAA,EAC1E;AAAA,EAEA,MAAM,2BACJ,WACyB;AACzB,WAAO,KAAK,QAAQ,gBAAgB,SAAS;AAAA,EAC/C;AAAA,EAEA,MAAM,6BAAsD;AAC1D,UAAM,UAAU,MAAM,KAAK,mBAAmB;AAC9C,WAAO,QAAQ,OAAO,CAAC,WAAW,OAAO,wCAA+B;AAAA,EAC1E;AAAA,EAEA,MAAM,eAAkC;AACtC,WAAO,KAAK;AAAA,EACd;AACF;","names":["IntentStatus","IntentType","TransactionType","AssetType"]}