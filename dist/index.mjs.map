{"version":3,"sources":["../src/types.ts","../src/adapters/InMemoryStorageAdapter.ts","../src/adapters/PlasmoStorageAdapter.ts","../src/providers/SandshrewRpcProvider.ts","../src/helpers.ts","../src/handlers/TransactionHandler.ts","../src/IntentSynchronizer.ts","../src/IntentManager.ts"],"sourcesContent":["export enum IntentType {\n  Transaction = \"transaction\",\n}\n\nexport enum IntentStatus {\n  Pending = \"pending\",\n  Completed = \"completed\",\n  Failed = \"failed\",\n}\n\nexport enum TransactionType {\n  Send = \"send\",\n  Receive = \"receive\",\n  Trade = \"trade\",\n}\n\nexport type TransactionIntent = {\n  id: string;\n  timestamp: number;\n  address: string;\n  type: IntentType;\n  status: IntentStatus;\n  txType: TransactionType;\n  txIds: string[];\n  amountSats: number;\n  brc20s: BRC20Content[];\n  collectibles: Inscription[];\n  runes: string[];\n  traits: string[];\n};\n\nexport type Intent = TransactionIntent; // Add more types here\n\nexport interface IntentHandler {\n  captureIntent(intent: Intent): Promise<void>;\n  retrieveAllIntents(): Promise<Intent[]>;\n  retrievePendingIntents(): Promise<Intent[]>;\n  retrieveTransactionIntents(): Promise<Intent[]>;\n  retrieveIntentsByAddresses(addresses: string[]): Promise<Intent[]>;\n}\n\nexport interface IntentSynchronizer {\n  start(): Promise<void>;\n}\n\nexport interface StorageAdapter {\n  save(intent: Intent): Promise<void>;\n  findAll(): Promise<Intent[]>;\n  findByType(type: IntentType): Promise<Intent[]>;\n  findByStatus(status: IntentStatus): Promise<Intent[]>;\n  findByAddresses(addresses: string[]): Promise<Intent[]>;\n}\n\nexport interface RpcProvider {\n  baseUrl: string;\n  getTxById(txId: string): Promise<EsploraTransaction>;\n  getAddressTxs(address: string): Promise<EsploraTransaction[]>;\n  getTxOutput(txId: string, index: number): Promise<OrdOutput>;\n  getInscriptionById(inscriptionId: string): Promise<OrdInscription>;\n}\n\nexport interface EsploraTransaction {\n  txid: string;\n  version: number;\n  locktime: number;\n  vin: {\n    txid: string;\n    vout: number;\n    prevout: {\n      scriptpubkey: string;\n      scriptpubkey_asm: string;\n      scriptpubkey_type: string;\n      scriptpubkey_address: string;\n      value: number;\n    };\n    scriptsig: string;\n    scriptsig_asm: string;\n    witness: string[];\n    is_coinbase: boolean;\n    sequence: number;\n  }[];\n  vout: {\n    scriptpubkey: string;\n    scriptpubkey_asm: string;\n    scriptpubkey_type: string;\n    scriptpubkey_address: string;\n    value: number;\n  }[];\n  size: number;\n  weight: number;\n  fee: number;\n  status: {\n    confirmed: boolean;\n    block_height?: number;\n    block_hash?: string;\n    block_time?: number;\n  };\n}\n\nexport interface OrdOutput {\n  address: string;\n  indexed: boolean;\n  inscriptions: string[];\n  runes: any[];\n  sat_ranges: number[][];\n  script_pubkey: string;\n  spent: boolean;\n  transaction: string;\n  value: number;\n}\n\nexport type OrdInscription = {\n  content_type: string;\n  content: string;\n};\n\nexport type Inscription = {\n  id: string;\n  content_type: string;\n  content: string;\n};\n\nexport interface BRC20Content {\n  p: string;\n  op: string;\n  amt: string;\n  tick: string;\n  max?: string;\n  lim?: string;\n}\n","import { Intent, IntentStatus, IntentType, StorageAdapter } from \"../types\";\n\nexport class InMemoryStorageAdapter implements StorageAdapter {\n  private intents: Intent[] = [];\n\n  async save(intent: Intent): Promise<void> {\n    if (intent.id) {\n      const newIntents = this.intents.map((existingIntent) => {\n        if (existingIntent.id === intent.id) {\n          return structuredClone({\n            ...existingIntent,\n            ...intent,\n          });\n        }\n        return existingIntent;\n      });\n\n      this.intents = newIntents;\n    } else {\n      this.intents.push(\n        structuredClone({\n          ...intent,\n          id: Math.random().toString(36).substring(7),\n          timestamp: Date.now(),\n        })\n      );\n    }\n  }\n\n  async findAll(): Promise<Intent[]> {\n    return structuredClone(this.intents);\n  }\n\n  async findByType(type: IntentType): Promise<Intent[]> {\n    return structuredClone(\n      this.intents.filter((intent) => intent.type === type)\n    );\n  }\n\n  async findByStatus(status: IntentStatus): Promise<Intent[]> {\n    return structuredClone(\n      this.intents.filter((intent) => intent.status === status)\n    );\n  }\n\n  async findByAddresses(addresses: string[]): Promise<Intent[]> {\n    return structuredClone(\n      this.intents.filter((intent) => addresses.includes(intent.address))\n    );\n  }\n}\n","import { Intent, IntentStatus, IntentType, StorageAdapter } from \"../types\";\nimport { Storage } from \"@plasmohq/storage\";\n\nexport class PlasmoStorageAdapter implements StorageAdapter {\n  private storage: Storage;\n  private key: string;\n\n  constructor(key: string) {\n    this.key = key;\n    this.storage = new Storage({\n      area: \"local\",\n    });\n  }\n\n  async save(intent: Intent): Promise<void> {\n    const intents = await this.findAll();\n\n    if (intent.id) {\n      const newIntents = intents.map((existingIntent) => {\n        if (existingIntent.id === intent.id) {\n          return {\n            ...existingIntent,\n            ...intent,\n          };\n        }\n        return existingIntent;\n      });\n\n      return this.storage.set(this.key, newIntents);\n    } else {\n      intents.push(\n        structuredClone({\n          ...intent,\n          id: Math.random().toString(36).substring(7),\n          timestamp: Date.now(),\n        })\n      );\n\n      return this.storage.set(this.key, intents);\n    }\n  }\n\n  async findAll(): Promise<Intent[]> {\n    return this.storage\n      .get<Intent[]>(this.key)\n      .then((intents) => intents || []);\n  }\n\n  async findByType(type: IntentType): Promise<Intent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.type === type)\n    );\n  }\n\n  async findByStatus(status: IntentStatus): Promise<Intent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => intent.status === status)\n    );\n  }\n\n  async findByAddresses(addresses: string[]): Promise<Intent[]> {\n    return this.findAll().then((intents) =>\n      intents.filter((intent) => addresses.includes(intent.address))\n    );\n  }\n}\n","import {\n  RpcProvider,\n  EsploraTransaction,\n  OrdInscription,\n  OrdOutput,\n} from \"../types\";\n\nexport class SandshrewRpcProvider implements RpcProvider {\n  baseUrl: string;\n\n  constructor({ network, projectId }: { network: string; projectId: string }) {\n    if (network === \"regtest\") {\n      this.baseUrl = \"http://localhost:3000/v1/regtest\";\n    } else {\n      this.baseUrl = `https://${network}.sandshrew.io/v1/${projectId}`;\n    }\n  }\n\n  async getAddressTxs(address: string): Promise<EsploraTransaction[]> {\n    try {\n      const response = await fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"esplora_address::txs\",\n          params: [address],\n        }),\n      });\n\n      const data = await response.json();\n      return data.result;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  async getTxById(txId: string): Promise<EsploraTransaction> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"esplora_tx\",\n        params: [txId],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n\n  async getTxOutput(txId: string, voutIndex: number): Promise<OrdOutput> {\n    const response = await fetch(this.baseUrl, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"ord_output\",\n        params: [`${txId}:${voutIndex}`],\n      }),\n    });\n\n    const data = await response.json();\n    return data.result;\n  }\n\n  async getInscriptionById(inscriptionId: string): Promise<OrdInscription> {\n    const [inscriptionResponse, contentResponse] = await Promise.all([\n      fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"ord_inscription\",\n          params: [inscriptionId],\n        }),\n      }),\n      fetch(this.baseUrl, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: 1,\n          method: \"ord_content\",\n          params: [inscriptionId],\n        }),\n      }),\n    ]);\n\n    const inscriptionData = await inscriptionResponse.json();\n    const contentData = await contentResponse.json();\n\n    return {\n      ...inscriptionData.result,\n      content: contentData.result,\n    };\n  }\n}\n","import { parseWitness } from \"micro-ordinals\";\nimport { BRC20Content, EsploraTransaction, Inscription } from \"./types\";\n\nexport function isReceiveTx(tx, addresses) {\n  const outputsToAddress = tx.vout.filter((output) =>\n    addresses.includes(output.scriptpubkey_address)\n  );\n  const inputsFromAddress = tx.vin.some((input) =>\n    addresses.includes(input.prevout.scriptpubkey_address)\n  );\n\n  return outputsToAddress.length > 0 && !inputsFromAddress;\n}\n\nexport function txIntentExists(tx, intents) {\n  return intents.some((intent) => intent.data.txIds.includes(tx.txid));\n}\n\nexport function determineReceiverAddress(\n  tx: EsploraTransaction,\n  addresses: string[]\n) {\n  for (const output of tx.vout) {\n    if (addresses.includes(output.scriptpubkey_address)) {\n      return output.scriptpubkey_address;\n    }\n  }\n}\n\nexport function determineReceiverAmount(\n  tx: EsploraTransaction,\n  addresses: string[]\n) {\n  let amount = 0;\n\n  for (const output of tx.vout) {\n    if (addresses.includes(output.scriptpubkey_address)) {\n      amount += output.value;\n    }\n  }\n\n  return amount;\n}\n\nexport function inscriptionIdsFromTxOutputs(txOutputs) {\n  let inscriptionIds = [];\n  for (let output of txOutputs) {\n    inscriptionIds = inscriptionIds.concat(output.inscriptions);\n  }\n\n  return inscriptionIds;\n}\n\nexport function getInscriptionsFromInput(input: {\n  txid: string;\n  witness: string[];\n}) {\n  if (input.witness.length < 3) return [];\n\n  const inscriptions = [];\n\n  const parsedInscriptions = parseWitness(\n    input.witness.map((witness) => Uint8Array.from(Buffer.from(witness, \"hex\")))\n  );\n\n  for (let inscription of parsedInscriptions) {\n    inscriptions.push({\n      id: `${input.txid}i0`,\n      content_type: inscription.tags.contentType,\n      content: uint8ArrayToBase64(inscription.body),\n    });\n  }\n\n  return inscriptions;\n}\n\nexport function uint8ArrayToBase64(uint8Array: Uint8Array) {\n  let binaryString = \"\";\n  const len = uint8Array.byteLength;\n  for (let i = 0; i < len; i++) {\n    binaryString += String.fromCharCode(uint8Array[i]);\n  }\n  return btoa(binaryString);\n}\n\nexport function parseBrc20Inscription(\n  inscription: Inscription\n): BRC20Content | null {\n  const contentBuffer = Buffer.from(inscription.content, \"base64\");\n\n  try {\n    let parsed = JSON.parse(contentBuffer.toString());\n    if (parsed.p === \"brc-20\") {\n      return parsed;\n    }\n  } catch {}\n\n  return null;\n}\n","import { IntentManager } from \"../IntentManager\";\nimport {\n  parseBrc20Inscription,\n  determineReceiverAddress,\n  getInscriptionsFromInput,\n  inscriptionIdsFromTxOutputs,\n  isReceiveTx,\n  txIntentExists,\n  determineReceiverAmount,\n} from \"../helpers\";\nimport {\n  IntentType,\n  IntentStatus,\n  EsploraTransaction,\n  Intent,\n  BRC20Content,\n  Inscription,\n  RpcProvider,\n  TransactionType,\n} from \"../types\";\n\nexport class TransactionHandler {\n  private addresses: string[] = [];\n\n  constructor(private manager: IntentManager, private provider: RpcProvider) {}\n\n  async setAddresses(addresses: string[]) {\n    this.addresses = addresses;\n  }\n\n  async handlePendingTransaction(intent: Intent) {\n    const txs = await Promise.all(\n      intent.txIds.map((txId: string) => this.provider.getTxById(txId))\n    );\n\n    if (txs.every((tx) => tx.status.confirmed)) {\n      intent.status = IntentStatus.Completed;\n      await this.manager.captureIntent(intent);\n    }\n  }\n\n  async handleReceivedTransactions(addresses: string[]) {\n    this.addresses = addresses;\n\n    const intents = await this.manager.retrieveIntentsByAddresses(\n      this.addresses\n    );\n    if (intents.some(({ txIds }) => txIds.length === 0)) return;\n\n    const txs = (\n      await Promise.all(\n        this.addresses.map((addr) => this.provider.getAddressTxs(addr))\n      )\n    ).flat();\n    for (let tx of txs) {\n      if (!isReceiveTx(tx, this.addresses) || txIntentExists(tx, intents))\n        continue;\n      await this.processTransaction(tx);\n    }\n  }\n\n  private async processTransaction(tx: EsploraTransaction) {\n    const inscriptions = await this.getInscriptions(tx);\n\n    const { brc20s, runes, collectibles } =\n      this.categorizeInscriptions(inscriptions);\n\n    const traits = new Set<string>();\n\n    if (brc20s.length > 0) {\n      traits.add(\"token\");\n      traits.add(\"brc20\");\n      brc20s.forEach((brc20) => {\n        traits.add(brc20.op);\n      });\n    }\n\n    if (runes.length > 0) {\n      traits.add(\"token\");\n      traits.add(\"rune\");\n      // TODO: Add rune traits like etching, mint, etc\n    }\n\n    if (collectibles.length > 0) {\n      traits.add(\"collectible\");\n      collectibles.forEach((collectible) => {\n        traits.add(collectible.content_type);\n      });\n    } else {\n      traits.add(\"token\");\n    }\n\n    const amountSats = determineReceiverAmount(tx, this.addresses);\n\n    await this.manager.captureIntent({\n      address: determineReceiverAddress(tx, this.addresses),\n      type: IntentType.Transaction,\n      status: tx.status.confirmed\n        ? IntentStatus.Completed\n        : IntentStatus.Pending,\n      txType: TransactionType.Receive,\n      txIds: [tx.txid],\n      amountSats,\n      brc20s,\n      collectibles,\n      runes: [],\n      traits: Array.from(traits),\n    });\n  }\n\n  private async getInscriptions(tx: EsploraTransaction): Promise<any[]> {\n    let inscriptions = await this.getTxOutputsInscriptions(tx);\n    if (inscriptions.length === 0) {\n      inscriptions = await this.getPrevOutputsInscriptions(tx);\n    }\n    if (inscriptions.length === 0) {\n      inscriptions = this.getInputInscriptions(tx);\n    }\n    return inscriptions;\n  }\n\n  private async getTxOutputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    const voutIndexes = tx.vout\n      .map((output, index) =>\n        this.addresses.includes(output.scriptpubkey_address) ? index : null\n      )\n      .filter((index) => index !== null);\n    const txOutputs = await Promise.all(\n      voutIndexes.map((voutIndex) =>\n        this.provider.getTxOutput(tx.txid, voutIndex)\n      )\n    );\n\n    if (txOutputs.every((output) => output.indexed)) {\n      return Promise.all(\n        inscriptionIdsFromTxOutputs(txOutputs).map((id) =>\n          this.provider.getInscriptionById(id)\n        )\n      );\n    }\n    return [];\n  }\n\n  private async getPrevOutputsInscriptions(\n    tx: EsploraTransaction\n  ): Promise<any[]> {\n    const txPrevOutputs = await Promise.all(\n      tx.vin.map(({ txid, vout }) => this.provider.getTxOutput(txid, vout))\n    );\n    return Promise.all(\n      inscriptionIdsFromTxOutputs(txPrevOutputs).map((id) =>\n        this.provider.getInscriptionById(id)\n      )\n    );\n  }\n\n  private getInputInscriptions(tx: EsploraTransaction): any[] {\n    return tx.vin.flatMap((input) => getInscriptionsFromInput(input));\n  }\n\n  private categorizeInscriptions(inscriptions: Inscription[]): {\n    brc20s: BRC20Content[];\n    runes: any[];\n    collectibles: Inscription[];\n  } {\n    const brc20s = [];\n    const collectibles = [];\n    for (let inscription of inscriptions) {\n      const brc20 = parseBrc20Inscription(inscription);\n      if (brc20) {\n        brc20s.push(brc20);\n      } else {\n        collectibles.push(inscription);\n      }\n    }\n    return { brc20s, runes: [], collectibles };\n  }\n}\n","import { IntentManager } from \"./IntentManager\";\nimport { TransactionHandler } from \"./handlers\";\nimport { RpcProvider, IntentType } from \"./types\";\n\nexport class IntentSynchronizer {\n  private transactionHandler: TransactionHandler;\n\n  constructor(private manager: IntentManager, provider: RpcProvider) {\n    this.transactionHandler = new TransactionHandler(manager, provider);\n  }\n\n  async syncPendingIntents() {\n    const pendingIntents = await this.manager.retrievePendingIntents();\n    await Promise.all(\n      pendingIntents.map(async (intent) => {\n        if (intent.type === IntentType.Transaction) {\n          await this.transactionHandler.handlePendingTransaction(intent);\n        }\n      })\n    );\n  }\n\n  async syncReceivedTxIntents(addresses: string[]) {\n    const intents = await this.manager.retrieveTransactionIntents();\n    if (intents.every(({ txIds }) => txIds.length > 0)) {\n      await this.transactionHandler.handleReceivedTransactions(addresses);\n    }\n  }\n}\n","import {\n  Intent,\n  IntentHandler,\n  IntentStatus,\n  IntentType,\n  StorageAdapter,\n} from \"./types\";\n\nexport class IntentManager implements IntentHandler {\n  constructor(\n    private storage: StorageAdapter,\n    private addresses: string[] = []\n  ) {}\n\n  async captureIntent(intent: Omit<Intent, \"id\" | \"timestamp\">): Promise<void> {\n    await this.storage.save(intent as Intent);\n  }\n\n  async retrieveAllIntents(): Promise<Intent[]> {\n    return this.storage.findAll();\n  }\n\n  async retrievePendingIntents(): Promise<Intent[]> {\n    const intents = await this.retrieveAllIntents();\n    return intents.filter((intent) => intent.status === IntentStatus.Pending);\n  }\n\n  async retrieveIntentsByAddresses(addresses: string[]): Promise<Intent[]> {\n    return this.storage.findByAddresses(addresses);\n  }\n\n  async retrieveTransactionIntents(): Promise<Intent[]> {\n    const intents = await this.retrieveAllIntents();\n    return intents.filter((intent) => intent.type === IntentType.Transaction);\n  }\n\n  async getAddresses(): Promise<string[]> {\n    return this.addresses;\n  }\n}\n"],"mappings":"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","names":["IntentType","IntentStatus","TransactionType"]}